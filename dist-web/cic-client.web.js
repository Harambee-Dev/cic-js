/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
window.cic =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/bancor/convert.js":
/*!********************************!*\
  !*** ./dist/bancor/convert.js ***!
  \********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/*! CommonJS bailout: this is used directly at 11:19-23 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Conversion = void 0;\nvar tx_1 = __webpack_require__(/*! ../common/tx */ \"./dist/common/tx.js\");\nvar topic_convert = '0x7154b38b5dd31bb3122436a96d4e09aba5b323ae1fd580025fab55074334c095';\n/**\n * Instance represents a single conversion event on network.\n *\n * @class Conversion\n */\nvar Conversion = /** @class */ (function () {\n    /**\n     *\n     * @param tx Ethereum transaction\n     * @param sourceToken ERC20 token sent in conversion\n     * @param destinationToken ERC20 token received from conversion\n     * @param trader Ethereum address performing the conversion (sender and recipient)\n     * @param fromValue Source token value of conversion\n     * @param toValue Destination token value of conversion\n     */\n    function Conversion(tx, sourceToken, destinationToken, trader, fromValue, toValue) {\n        this.sourceToken = sourceToken;\n        this.destinationToken = destinationToken;\n        this.trader = trader;\n        this.fromValue = fromValue;\n        this.toValue = toValue;\n        this.tx = tx;\n    }\n    /**\n     * Scans a transaction log for transfer event.\n     *\n     * @static\n     * @param w3 A connected Web3 object\n     * @param registry Registry context of conversion\n     * @param success State of transaction\n     * @param log A Web3 transaction receipt logs array\n     * @return conversion Instance of Conversion if conversion is found, undefined if not.\n     */\n    Conversion.processLog = function (w3, registry, success, log) {\n        return __awaiter(this, void 0, void 0, function () {\n            var conversion, block, sourceToken_address, sourceToken, destinationToken_address, destinationToken, fromValue, toValue, trader, tx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        conversion = undefined;\n                        if (!(log.topics[0] == topic_convert)) return [3 /*break*/, 4];\n                        return [4 /*yield*/, w3.eth.getBlock(log.blockNumber)];\n                    case 1:\n                        block = _a.sent();\n                        sourceToken_address = w3.utils.toChecksumAddress('0x' + log.topics[1].substring(26, 66));\n                        return [4 /*yield*/, registry.getToken(sourceToken_address)];\n                    case 2:\n                        sourceToken = _a.sent();\n                        destinationToken_address = w3.utils.toChecksumAddress('0x' + log.topics[2].substring(26, 66));\n                        return [4 /*yield*/, registry.getToken(destinationToken_address)];\n                    case 3:\n                        destinationToken = _a.sent();\n                        fromValue = BigInt(log.data.substring(0, 66));\n                        toValue = BigInt(log.data.substring(0, 66));\n                        trader = w3.utils.toChecksumAddress('0x' + log.data.substring(154));\n                        tx = new tx_1.Tx(log.blockNumber, log.transactionIndex, log.transactionHash, block.timestamp, success);\n                        conversion = new Conversion(tx, sourceToken, destinationToken, trader, fromValue, toValue);\n                        console.log('convert', conversion);\n                        _a.label = 4;\n                    case 4: return [2 /*return*/, conversion];\n                }\n            });\n        });\n    };\n    return Conversion;\n}());\nexports.Conversion = Conversion;\n\n\n//# sourceURL=webpack://cic/./dist/bancor/convert.js?");

/***/ }),

/***/ "./dist/common/erc20.js":
/*!******************************!*\
  !*** ./dist/common/erc20.js ***!
  \******************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 7:17-21 */
/*! CommonJS bailout: this is used directly at 16:19-23 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Provides a representation of a token transfer transaction, aswell as a processor to detect transfer events.\n *\n * @module erc20\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.topics = exports.Token = exports.Transfer = void 0;\nvar tx_1 = __webpack_require__(/*! ./tx */ \"./dist/common/tx.js\");\nvar topics = {\n    'transfer': '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n};\nexports.topics = topics;\n/**\n * A Transfer instance represents a single ERC20 token transfer.\n *\n * @class Transfer\n */\nvar Transfer = /** @class */ (function () {\n    /**\n     *\n     * @param tx A transaction object\n     * @param token Ethereum address of ERC20 token transferred\n     * @param from Ethereum address of sender\n     * @param to Ethereum address of receipient\n     * @param value Value of transfer\n     */\n    function Transfer(tx, token, from, to, value) {\n        this.from = from;\n        this.to = to;\n        this.token = token;\n        this.value = value;\n        this.tx = tx;\n    }\n    /**\n     * Scans a transaction log for transfer event.\n     *\n     * @static\n     * @param w3 A connected Web3 object\n     * @param success State of transaction\n     * @param token Token address to find transfer for\n     * @param log A Web3 transaction receipt logs array\n     * @return transfer Instance of Transfer if transfer is found, undefined if not.\n     */\n    Transfer.processLog = function (w3, success, token, log) {\n        return __awaiter(this, void 0, void 0, function () {\n            var transfer, block, from, to, value, tx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        transfer = undefined;\n                        if (!(log.topics[0] == topics['transfer'])) return [3 /*break*/, 2];\n                        return [4 /*yield*/, w3.eth.getBlock(log.blockNumber)];\n                    case 1:\n                        block = _a.sent();\n                        from = w3.utils.toChecksumAddress(log.topics[1].substring(26, 66));\n                        to = w3.utils.toChecksumAddress(log.topics[2].substring(26, 66));\n                        value = BigInt(log.data);\n                        tx = new tx_1.Tx(log.blockNumber, log.transactionIndex, log.transactionHash, block.timestamp, success);\n                        transfer = new Transfer(tx, token, from, to, value);\n                        _a.label = 2;\n                    case 2: return [2 /*return*/, transfer];\n                }\n            });\n        });\n    };\n    return Transfer;\n}());\nexports.Transfer = Transfer;\n/**\n * Metadata for a single ERC20 token.\n *\n * @class Token\n *\n */\nvar Token = /** @class */ (function () {\n    /**\n     *\n     * @param address Ethereum address of token contract\n     * @param name ERC20 token name\n     * @param symbol ERC20 token symbol\n     */\n    function Token(address, name, symbol, decimals, totalSupply) {\n        this.address = address;\n        this.name = name;\n        this.symbol = symbol;\n        this.totalSupply = totalSupply;\n        this.decimals = decimals;\n    }\n    /**\n     * Informal string representation of token.\n     *\n     */\n    Token.prototype.toString = function () {\n        return 'Token: ' + this.name + ' (' + this.symbol + ')';\n    };\n    return Token;\n}());\nexports.Token = Token;\n\n\n//# sourceURL=webpack://cic/./dist/common/erc20.js?");

/***/ }),

/***/ "./dist/common/tx.js":
/*!***************************!*\
  !*** ./dist/common/tx.js ***!
  \***************************/
/*! flagged exports */
/*! export Log [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Tx [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * Abstractions of Web3 transactions and transaction receipt logs\n *\n * @module tx\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Log = exports.Tx = void 0;\n/**\n * Instance encapsulates metadata of a single mined transaction.\n *\n * @class Tx\n */\nvar Tx = /** @class */ (function () {\n    /**\n     *\n     * @param block Block number\n     * @param txIndex Transaction index in block\n     * @param txHash Transaction hash\n     * @param timestamp Block timestamp\n     * @param success Whether transaction was successful\n     */\n    function Tx(block, txIndex, txHash, timestamp, success) {\n        this.block = block;\n        this.txIndex = txIndex;\n        this.txHash = txHash;\n        this.timestamp = timestamp;\n        this.success = success;\n    }\n    return Tx;\n}());\nexports.Tx = Tx;\n/**\n * Represents a single Web3 transaction receipt Log entry\n *\n * @class Log\n * @todo Should be changed to type def instead\n */\nvar Log = /** @class */ (function () {\n    function Log() {\n    }\n    return Log;\n}());\nexports.Log = Log;\n\n\n//# sourceURL=webpack://cic/./dist/common/tx.js?");

/***/ }),

/***/ "./dist/const.js":
/*!***********************!*\
  !*** ./dist/const.js ***!
  \***********************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export zeroAddress [provided] [no usage info] [missing usage info prevents renaming] */
/*! export zeroContent [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.zeroAddress = exports.zeroContent = void 0;\nvar zeroContent = '0x0000000000000000000000000000000000000000000000000000000000000000';\nexports.zeroContent = zeroContent;\nvar zeroAddress = '0x0000000000000000000000000000000000000000';\nexports.zeroAddress = zeroAddress;\n\n\n//# sourceURL=webpack://cic/./dist/const.js?");

/***/ }),

/***/ "./dist/crypto.js":
/*!************************!*\
  !*** ./dist/crypto.js ***!
  \************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:23-27 */
/*! CommonJS bailout: this is used directly at 9:26-30 */
/*! CommonJS bailout: this is used directly at 14:20-24 */
/*! CommonJS bailout: this is used directly at 21:17-21 */
/*! CommonJS bailout: this is used directly at 30:19-23 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.subtle = void 0;\nvar crypto = __importStar(__webpack_require__(/*! crypto */ \"?8465\"));\nvar _algs = {\n    'SHA-256': 'sha256',\n};\nfunction cryptoWrapper() {\n}\ncryptoWrapper.prototype.digest = function (s, d) {\n    return __awaiter(this, void 0, void 0, function () {\n        var h;\n        return __generator(this, function (_a) {\n            h = crypto.createHash(_algs[s]);\n            h.update(d);\n            return [2 /*return*/, h.digest()];\n        });\n    });\n};\nvar subtle = undefined;\nexports.subtle = subtle;\nif (typeof window !== 'undefined') {\n    exports.subtle = subtle = window.crypto.subtle;\n}\nelse {\n    exports.subtle = subtle = new cryptoWrapper();\n}\n\n\n//# sourceURL=webpack://cic/./dist/crypto.js?");

/***/ }),

/***/ "./dist/digest.js":
/*!************************!*\
  !*** ./dist/digest.js ***!
  \************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:23-27 */
/*! CommonJS bailout: this is used directly at 9:26-30 */
/*! CommonJS bailout: this is used directly at 14:20-24 */
/*! CommonJS bailout: this is used directly at 21:17-21 */
/*! CommonJS bailout: this is used directly at 30:19-23 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addressToBytes = exports.bytesToHex = exports.toAddressKey = exports.toKey = void 0;\nvar crypto = __importStar(__webpack_require__(/*! ./crypto */ \"./dist/crypto.js\"));\nfunction stringToBytes(s) {\n    var a = new Uint8Array(20);\n    var j = 2;\n    for (var i = 0; i < a.byteLength; i++) {\n        var n = parseInt(s.substring(j, j + 2), 16);\n        a[i] = n;\n        j += 2;\n    }\n    return a;\n}\nfunction bytesToHex(a) {\n    var s = '';\n    for (var i = 0; i < a.byteLength; i++) {\n        var h = '00' + a[i].toString(16);\n        s += h.slice(-2);\n    }\n    return s;\n}\nexports.bytesToHex = bytesToHex;\nfunction mergeKey(a, s) {\n    return __awaiter(this, void 0, void 0, function () {\n        var y, i, i, z;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    y = new Uint8Array(a.byteLength + s.byteLength);\n                    for (i = 0; i < a.byteLength; i++) {\n                        y[i] = a[i];\n                    }\n                    for (i = 0; i < s.byteLength; i++) {\n                        y[a.byteLength + i] = s[i];\n                    }\n                    return [4 /*yield*/, crypto.subtle.digest('SHA-256', y)];\n                case 1:\n                    z = _a.sent();\n                    return [2 /*return*/, bytesToHex(new Uint8Array(z))];\n            }\n        });\n    });\n}\nfunction toKey(v, salt) {\n    return __awaiter(this, void 0, void 0, function () {\n        var a, s;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    a = stringToBytes(v);\n                    s = new TextEncoder().encode(salt);\n                    return [4 /*yield*/, mergeKey(a, s)];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\nexports.toKey = toKey;\nfunction toAddressKey(zeroExHex, salt) {\n    return __awaiter(this, void 0, void 0, function () {\n        var a, s;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    a = addressToBytes(zeroExHex);\n                    s = new TextEncoder().encode(salt);\n                    return [4 /*yield*/, mergeKey(a, s)];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\nexports.toAddressKey = toAddressKey;\nvar re_addrHex = /^0[xX][a-fA-F0-9]{40}$/;\nfunction addressToBytes(s) {\n    if (!s.match(re_addrHex)) {\n        throw 'invalid address hex';\n    }\n    return stringToBytes(s);\n}\nexports.addressToBytes = addressToBytes;\n\n\n//# sourceURL=webpack://cic/./dist/digest.js?");

/***/ }),

/***/ "./dist/helper.js":
/*!************************!*\
  !*** ./dist/helper.js ***!
  \************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 7:17-21 */
/*! CommonJS bailout: this is used directly at 16:19-23 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Provides processing of Ethereum transaction receipts relevant for the CIC network.\n *\n * @module helper\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TokenDeclarationHelper = exports.TransactionHelper = exports.DeclaratorHelper = void 0;\nvar erc20_1 = __webpack_require__(/*! ./common/erc20 */ \"./dist/common/erc20.js\");\nvar convert_1 = __webpack_require__(/*! ./bancor/convert */ \"./dist/bancor/convert.js\");\nvar solidity_1 = __webpack_require__(/*! ./solidity */ \"./dist/solidity.js\");\nvar const_1 = __webpack_require__(/*! ./const */ \"./dist/const.js\");\n/**\n * Reduced, concrete view of a transaction receipt.\n *\n * @todo Is there a way of importing the web3 type instead?\n */\nvar Receipt = /** @class */ (function () {\n    function Receipt() {\n    }\n    return Receipt;\n}());\n/**\n * Receipt processor within context of a given registry.\n *\n */\nvar TransactionHelper = /** @class */ (function () {\n    /**\n     *\n     * @param registry The registry context to use\n     */\n    function TransactionHelper(w3, registry) {\n        this.w3 = w3;\n        this.registry = registry;\n        this.ontransfer = function (t) {\n            console.debug('transfer ', t);\n        };\n        this.onconversion = function (c) {\n            console.debug('convert ', c);\n        };\n    }\n    /**\n     * Processes a single receipt to find conversion and token transfer events.\n     *\n     * If a transfer is found, ontransfer callback will be called with a Transfer instance.\n     * If a conversion is found, onconvsrsion callback will be called with a Conversion instance.\n     *\n     * @param r A Web3 transaction receipt.\n     * @todo The from-amount of convert is currently wrong, but be retrieved from the initial transfer log entry instead.\n     */\n    TransactionHelper.prototype.processReceipt = function (r) {\n        return __awaiter(this, void 0, void 0, function () {\n            var self, logs, convert_log, token_txs, i, contractAddress, t, e_1, d, t, e_2, e_3, conversion, _i, token_txs_1, a, transfer;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        self = this;\n                        logs = r.logs;\n                        convert_log = undefined;\n                        token_txs = [];\n                        i = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i < logs.length)) return [3 /*break*/, 15];\n                        contractAddress = logs[i].address;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 14]);\n                        return [4 /*yield*/, this.registry.getToken(contractAddress)];\n                    case 3:\n                        t = _a.sent();\n                        token_txs.push([r.status, t, logs[i]]);\n                        return [3 /*break*/, 14];\n                    case 4:\n                        e_1 = _a.sent();\n                        _a.label = 5;\n                    case 5:\n                        _a.trys.push([5, 8, , 13]);\n                        return [4 /*yield*/, this.registry.getAddressDeclaration('AddressDeclarator', contractAddress)];\n                    case 6:\n                        d = _a.sent();\n                        console.debug('trust record for ' + contractAddress + ' found', d);\n                        return [4 /*yield*/, this.registry.addToken(contractAddress)];\n                    case 7:\n                        t = _a.sent();\n                        token_txs.push([r.status, t, logs[i]]);\n                        return [3 /*break*/, 13];\n                    case 8:\n                        e_2 = _a.sent();\n                        _a.label = 9;\n                    case 9:\n                        _a.trys.push([9, 11, , 12]);\n                        return [4 /*yield*/, this.registry.getContract(contractAddress)];\n                    case 10:\n                        _a.sent();\n                        convert_log = logs[i];\n                        return [3 /*break*/, 15];\n                    case 11:\n                        e_3 = _a.sent();\n                        return [3 /*break*/, 14];\n                    case 12: return [3 /*break*/, 13];\n                    case 13: return [3 /*break*/, 14];\n                    case 14:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 15:\n                        if (!(convert_log !== undefined)) return [3 /*break*/, 17];\n                        return [4 /*yield*/, convert_1.Conversion.processLog(this.w3, this.registry, r.status, convert_log)];\n                    case 16:\n                        conversion = _a.sent();\n                        if (conversion !== undefined) {\n                            this.onconversion(conversion);\n                        }\n                        return [3 /*break*/, 21];\n                    case 17:\n                        _i = 0, token_txs_1 = token_txs;\n                        _a.label = 18;\n                    case 18:\n                        if (!(_i < token_txs_1.length)) return [3 /*break*/, 21];\n                        a = token_txs_1[_i];\n                        return [4 /*yield*/, erc20_1.Transfer.processLog(this.w3, a[0], a[1], a[2])];\n                    case 19:\n                        transfer = _a.sent();\n                        if (transfer !== undefined) {\n                            this.ontransfer(transfer);\n                        }\n                        _a.label = 20;\n                    case 20:\n                        _i++;\n                        return [3 /*break*/, 18];\n                    case 21: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return TransactionHelper;\n}());\nexports.TransactionHelper = TransactionHelper;\n/**\n * Token query within the context of a registry.\n */\nvar TokenDeclarationHelper = /** @class */ (function () {\n    /**\n     *\n     * @param w3\n     * @param registry The registry context to use.\n     */\n    function TokenDeclarationHelper(w3, registry) {\n        this.registry = registry;\n        this.w3 = w3;\n    }\n    /**\n     * Check if a token fits the ERC20 standard.\n     *\n     * @param tokenAddress The address of the token to be checked.\n     */\n    TokenDeclarationHelper.prototype.assertERC20TokenType = function (tokenAddress) {\n        return __awaiter(this, void 0, void 0, function () {\n            var erc20Abi, tokenContract, tokenSymbol, e_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.registry.getAbi('ERC20')];\n                    case 1:\n                        erc20Abi = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        tokenContract = new this.w3.eth.Contract(erc20Abi, tokenAddress);\n                        return [4 /*yield*/, tokenContract.methods.symbol().call()];\n                    case 3:\n                        tokenSymbol = _a.sent();\n                        if (tokenSymbol !== undefined) {\n                            return [2 /*return*/, true];\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_4 = _a.sent();\n                        console.log('contract ' + tokenAddress + ' is not an ERC20 token');\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, false];\n                }\n            });\n        });\n    };\n    return TokenDeclarationHelper;\n}());\nexports.TokenDeclarationHelper = TokenDeclarationHelper;\n/**\n * Declarator query within the context of a registry.\n */\nvar DeclaratorHelper = /** @class */ (function () {\n    /**\n     *\n     * @param w3\n     * @param registry The registry context to use.\n     */\n    function DeclaratorHelper(w3, registry) {\n        this.registry = registry;\n        this.trusts = [];\n        this.tokenHelper = new TokenDeclarationHelper(w3, registry);\n    }\n    /**\n     * Add an address to list of declarators to trust.\n     *\n     * @param address The address to be added to the trust list\n     */\n    DeclaratorHelper.prototype.addTrust = function (address) {\n        this.trusts.push(address);\n    };\n    /**\n     * Check for trust records of a token\n     *\n     *  if there are no trust records, an error will be thrown.\n     *\n     * @param tokenRegistryContractName The name of the token in the token registry.\n     * @param tokenAddress The address of the contract used to deploy the token.\n     * @param checkInterface A boolean on whether to to check the interface.\n     */\n    DeclaratorHelper.prototype.getTrustedTokenDeclaration = function (tokenRegistryContractName, tokenAddress, checkInterface) {\n        if (checkInterface === void 0) { checkInterface = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var i, isERC20, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i < this.trusts.length)) return [3 /*break*/, 7];\n                        console.debug('checking for trust record by ' + this.trusts[i] + ' for token ' + tokenAddress);\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 5, , 6]);\n                        return [4 /*yield*/, this.tokenHelper.assertERC20TokenType(tokenAddress)];\n                    case 3:\n                        isERC20 = _b.sent();\n                        if (isERC20) {\n                            console.log('contract ' + tokenAddress + ' is an ERC20 token');\n                        }\n                        return [4 /*yield*/, this.getTokenDeclaration(tokenRegistryContractName, this.trusts[i], tokenAddress, checkInterface)];\n                    case 4: return [2 /*return*/, _b.sent()];\n                    case 5:\n                        _a = _b.sent();\n                        return [3 /*break*/, 6];\n                    case 6:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 7: throw new Error('no trusted records for token ' + tokenAddress);\n                }\n            });\n        });\n    };\n    /**\n     * Check for trust records for a token by a declarator.\n     *\n     * @param tokenRegistryContractName The name of the token in the token registry.\n     * @param declarator The address of the declarator used to check for trust.\n     * @param tokenAddress The address of the contract used to deploy the token.\n     * @param checkInterface A boolean on whether to to check the interface.\n     */\n    DeclaratorHelper.prototype.getTokenDeclaration = function (tokenRegistryContractName, declarator, tokenAddress, checkInterface) {\n        if (checkInterface === void 0) { checkInterface = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenRegistryContract, declarationParts;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.registry.getContractByName(tokenRegistryContractName, 'AddressDeclarator', [solidity_1.interfaceCodes.Declarator])];\n                    case 1:\n                        tokenRegistryContract = _a.sent();\n                        return [4 /*yield*/, tokenRegistryContract.methods.declaration(declarator, tokenAddress).call()];\n                    case 2:\n                        declarationParts = _a.sent();\n                        if (declarationParts.length == 1 && declarationParts[0] == const_1.zeroAddress) {\n                            throw new Error('no declarations found for declarator \"' + declarator + '\" address \"' + tokenAddress + '\"');\n                        }\n                        return [2 /*return*/, declarationParts];\n                }\n            });\n        });\n    };\n    return DeclaratorHelper;\n}());\nexports.DeclaratorHelper = DeclaratorHelper;\n\n\n//# sourceURL=webpack://cic/./dist/helper.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/*! flagged exports */
/*! export CICRegistry [provided] [maybe used in index (runtime-defined)] [usage prevents renaming] */
/*! export TransactionHelper [provided] [maybe used in index (runtime-defined)] [usage prevents renaming] */
/*! export __esModule [provided] [maybe used in index (runtime-defined)] [usage prevents renaming] */
/*! other exports [not provided] [maybe used in index (runtime-defined)] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransactionHelper = exports.CICRegistry = void 0;\nvar registry_1 = __webpack_require__(/*! ./registry */ \"./dist/registry.js\");\nObject.defineProperty(exports, \"CICRegistry\", ({ enumerable: true, get: function () { return registry_1.CICRegistry; } }));\nvar helper_1 = __webpack_require__(/*! ./helper */ \"./dist/helper.js\");\nObject.defineProperty(exports, \"TransactionHelper\", ({ enumerable: true, get: function () { return helper_1.TransactionHelper; } }));\n\n\n//# sourceURL=webpack://cic/./dist/index.js?");

/***/ }),

/***/ "./dist/registry.js":
/*!**************************!*\
  !*** ./dist/registry.js ***!
  \**************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/*! CommonJS bailout: this is used directly at 11:19-23 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toRegistryKey = exports.toContractKey = exports.CICRegistry = void 0;\nvar helper_1 = __webpack_require__(/*! ./helper */ \"./dist/helper.js\");\nvar LRU = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/index.js\");\nvar solidity_1 = __webpack_require__(/*! ./solidity */ \"./dist/solidity.js\");\nvar const_1 = __webpack_require__(/*! ./const */ \"./dist/const.js\");\nvar crypto_1 = __webpack_require__(/*! ./crypto */ \"./dist/crypto.js\");\nvar digest_1 = __webpack_require__(/*! ./digest */ \"./dist/digest.js\");\nvar KV = /** @class */ (function () {\n    function KV() {\n        this.store = {};\n    }\n    KV.prototype.put = function (k, v) {\n        this.store[k] = v;\n    };\n    KV.prototype.get = function (k) {\n        return this.store[k];\n    };\n    KV.prototype.peek = function (k) {\n        return this.store[k];\n    };\n    return KV;\n}());\nvar CICRegistry = /** @class */ (function () {\n    function CICRegistry(w3, address, fileGetter, paths) {\n        this.w3 = w3;\n        this.address = address;\n        this.store = new KV();\n        this.paths = paths;\n        this.fileGetter = fileGetter;\n        this.declaratorHelper = new helper_1.DeclaratorHelper(w3, this);\n    }\n    CICRegistry.prototype.load = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var registryAbi, contractIdHex, contractId, confirmedContractAddress;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, solidity_1.abi(this.fileGetter, 'CICRegistry', this.paths)];\n                    case 1:\n                        registryAbi = _a.sent();\n                        this.contract = new this.w3.eth.Contract(registryAbi, this.address);\n                        contractIdHex = this.w3.utils.toHex('CICRegistry');\n                        contractId = this.w3.eth.abi.encodeParameter('bytes32', contractIdHex);\n                        return [4 /*yield*/, this.contract.methods.addressOf(contractId).call()];\n                    case 2:\n                        confirmedContractAddress = _a.sent();\n                        if (this.address != confirmedContractAddress) {\n                            throw new Error('cic registry contract entry does not match its own address');\n                        }\n                        if (this.onload !== undefined) {\n                            this.onload(this.address);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CICRegistry.prototype.getAbi = function (abiName) {\n        return __awaiter(this, void 0, void 0, function () {\n            var abiObject;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        abiObject = this.store.get(toAbiKey(abiName));\n                        if (!(abiObject === undefined)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, solidity_1.abi(this.fileGetter, abiName, this.paths)];\n                    case 1:\n                        abiObject = _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/, abiObject];\n                }\n            });\n        });\n    };\n    CICRegistry.prototype.addToken = function (address, requireTrust) {\n        if (requireTrust === void 0) { requireTrust = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var erc20Abi, tokenContract, tokenSymbol;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (requireTrust) {\n                            throw new Error('trust check not implemented yet, sorry');\n                        }\n                        return [4 /*yield*/, this.getAbi('ERC20')];\n                    case 1:\n                        erc20Abi = _a.sent();\n                        tokenContract = new this.w3.eth.Contract(erc20Abi, address);\n                        return [4 /*yield*/, tokenContract.methods.symbol().call()];\n                    case 2:\n                        tokenSymbol = _a.sent();\n                        if (tokenSymbol === undefined) {\n                            throw new Error('attempted to add token contract ' + address + ' which is not an ERC20 token');\n                        }\n                        this.store.put(toTokenKey(tokenSymbol), tokenContract);\n                        this.store.put(address, tokenContract);\n                        return [2 /*return*/, tokenContract];\n                }\n            });\n        });\n    };\n    CICRegistry.prototype.getContract = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var contract;\n            return __generator(this, function (_a) {\n                contract = this.store.get(address);\n                if (contract === undefined) {\n                    throw new Error('unknown contract ' + address);\n                }\n                return [2 /*return*/, contract];\n            });\n        });\n    };\n    CICRegistry.prototype.getToken = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenContract, tokenSymbol;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getContract(address)];\n                    case 1:\n                        tokenContract = _a.sent();\n                        return [4 /*yield*/, tokenContract.methods.symbol().call()];\n                    case 2:\n                        tokenSymbol = _a.sent();\n                        if (tokenSymbol === undefined) {\n                            throw new Error('contract ' + address + ' is not an ERC20 token');\n                        }\n                        return [2 /*return*/, tokenContract];\n                }\n            });\n        });\n    };\n    CICRegistry.prototype.getContractByName = function (contractName, abiName, requireInterfaces) {\n        return __awaiter(this, void 0, void 0, function () {\n            var contractKey, contract, contractAddress, contractAbi;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        contractKey = toContractKey(contractName);\n                        contract = this.store.get(contractKey);\n                        if (!(contract === undefined)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.getContractAddressByName(contractName, abiName, requireInterfaces)];\n                    case 1:\n                        contractAddress = _a.sent();\n                        if (abiName === undefined) {\n                            abiName = contractName;\n                        }\n                        return [4 /*yield*/, this.getAbi(abiName)];\n                    case 2:\n                        contractAbi = _a.sent();\n                        contract = new this.w3.eth.Contract(contractAbi, contractAddress);\n                        this.store.put(contractKey, contract);\n                        this.store.put(contractAddress, contract);\n                        _a.label = 3;\n                    case 3: return [2 /*return*/, contract];\n                }\n            });\n        });\n    };\n    CICRegistry.prototype.getContractAddressByName = function (contractName, abiName, requireInterfaces) {\n        return __awaiter(this, void 0, void 0, function () {\n            var contract_id_hex, contract_id, contractAddress;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        contract_id_hex = this.w3.utils.toHex(contractName);\n                        contract_id = this.w3.eth.abi.encodeParameter('bytes32', contract_id_hex);\n                        return [4 /*yield*/, this.contract.methods.addressOf(contract_id).call()];\n                    case 1:\n                        contractAddress = _a.sent();\n                        if (contractAddress == const_1.zeroAddress) {\n                            throw new Error('unknown contract ' + contractName + ' (' + contract_id_hex + ')');\n                        }\n                        return [2 /*return*/, contractAddress];\n                }\n            });\n        });\n    };\n    CICRegistry.prototype.getFungibleToken = function (tokenAddress, checkInterface) {\n        if (checkInterface === void 0) { checkInterface = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenAbi, tokenContract, tokenSymbol;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getAbi('ERC20')];\n                    case 1:\n                        tokenAbi = _a.sent();\n                        tokenContract = new this.w3.eth.Contract(tokenAbi, tokenAddress);\n                        if (checkInterface) {\n                            if (!tokenContract.methods.supportsInterface('ERC20')) {\n                                throw 'token does not declare ERC20 interface support';\n                            }\n                        }\n                        return [4 /*yield*/, tokenContract.methods.symbol().call()];\n                    case 2:\n                        tokenSymbol = _a.sent();\n                        this.store.put('token:' + tokenSymbol, tokenContract);\n                        this.store.put(tokenAddress, tokenContract);\n                        return [2 /*return*/, tokenContract];\n                }\n            });\n        });\n    };\n    CICRegistry.prototype.getAddressDeclaration = function (tokenRegistryContractName, tokenAddress, checkInterface) {\n        if (checkInterface === void 0) { checkInterface = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.declaratorHelper.getTrustedTokenDeclaration(tokenRegistryContractName, tokenAddress, checkInterface)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    CICRegistry.prototype.getTokenBySymbol = function (tokenRegistryContractName, symbol, checkInterface) {\n        if (checkInterface === void 0) { checkInterface = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenRegistryContract, symbolId, tokenAddress, token;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getContractByName(tokenRegistryContractName, 'Registry', [solidity_1.interfaceCodes.Registry])];\n                    case 1:\n                        tokenRegistryContract = _a.sent();\n                        return [4 /*yield*/, toRegistryKey(symbol)];\n                    case 2:\n                        symbolId = _a.sent();\n                        return [4 /*yield*/, tokenRegistryContract.methods.addressOf(symbolId).call()];\n                    case 3:\n                        tokenAddress = _a.sent();\n                        if (tokenAddress === const_1.zeroAddress) {\n                            throw 'unknown token \"' + symbol + '\" using registry \"' + tokenRegistryContractName + '\"';\n                        }\n                        token = this.getFungibleToken(tokenAddress, checkInterface);\n                        return [2 /*return*/, token];\n                }\n            });\n        });\n    };\n    return CICRegistry;\n}());\nexports.CICRegistry = CICRegistry;\nfunction toRegistryKey(s) {\n    return __awaiter(this, void 0, void 0, function () {\n        var sDigest, sId;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, crypto_1.subtle.digest('SHA-256', s)];\n                case 1:\n                    sDigest = _a.sent();\n                    sId = '0x' + digest_1.bytesToHex(sDigest);\n                    return [2 /*return*/, sId];\n            }\n        });\n    });\n}\nexports.toRegistryKey = toRegistryKey;\nfunction toContractKey(s) {\n    return 'contract:' + s;\n}\nexports.toContractKey = toContractKey;\nfunction toAbiKey(s) {\n    return 'abi:' + s;\n}\nfunction toTokenKey(s) {\n    return 'token:' + s;\n}\n\n\n//# sourceURL=webpack://cic/./dist/registry.js?");

/***/ }),

/***/ "./dist/solidity.js":
/*!**************************!*\
  !*** ./dist/solidity.js ***!
  \**************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/*! CommonJS bailout: this is used directly at 11:19-23 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.interfaceCodes = exports.bin = exports.abi = void 0;\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\nvar interfaceCodes = {\n    ERC20: '1da30d20',\n    Registry: '325d15e2',\n    Declarator: '00000000',\n};\nexports.interfaceCodes = interfaceCodes;\nfunction abi(fileGetter, interface_name, paths) {\n    return __awaiter(this, void 0, void 0, function () {\n        var d;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, findInPath(fileGetter, interface_name, 'json', paths)];\n                case 1:\n                    d = _a.sent();\n                    return [2 /*return*/, JSON.parse(d)];\n            }\n        });\n    });\n}\nexports.abi = abi;\nfunction bin(fileGetter, interface_name, paths) {\n    return __awaiter(this, void 0, void 0, function () {\n        var d;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, findInPath(fileGetter, interface_name, 'bin', paths)];\n                case 1:\n                    d = _a.sent();\n                    return [2 /*return*/, new TextDecoder('utf-8').decode(d)];\n            }\n        });\n    });\n}\nexports.bin = bin;\nfunction findInPath(fileGetter, stem, extension, paths) {\n    return __awaiter(this, void 0, void 0, function () {\n        var filename, found, e_1, i, filePath, d, e_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    filename = stem + '.' + extension;\n                    found = false;\n                    if (!(paths === undefined)) return [3 /*break*/, 5];\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, fileGetter.get(filename)];\n                case 2: return [2 /*return*/, _a.sent()];\n                case 3:\n                    e_1 = _a.sent();\n                    console.error(e_1);\n                    return [3 /*break*/, 4];\n                case 4: return [3 /*break*/, 11];\n                case 5:\n                    i = 0;\n                    _a.label = 6;\n                case 6:\n                    if (!(i < paths.length)) return [3 /*break*/, 11];\n                    filePath = path.join(paths[i], filename);\n                    d = void 0;\n                    _a.label = 7;\n                case 7:\n                    _a.trys.push([7, 9, , 10]);\n                    return [4 /*yield*/, fileGetter.get(filePath)];\n                case 8: return [2 /*return*/, _a.sent()];\n                case 9:\n                    e_2 = _a.sent();\n                    console.error(e_2);\n                    return [3 /*break*/, 10];\n                case 10:\n                    i++;\n                    return [3 /*break*/, 6];\n                case 11:\n                    if (!found) {\n                        throw new Error('file ' + filename + ' not found in data path');\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n\n\n//# sourceURL=webpack://cic/./dist/solidity.js?");

/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/*! CommonJS bailout: module.exports is used directly at 334:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/lru-cache/node_modules/yallist/yallist.js\")\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n\n\n//# sourceURL=webpack://cic/./node_modules/lru-cache/index.js?");

/***/ }),

/***/ "./node_modules/lru-cache/node_modules/yallist/iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lru-cache/node_modules/yallist/iterator.js ***!
  \*****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 2:0-14 */
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n\n\n//# sourceURL=webpack://cic/./node_modules/lru-cache/node_modules/yallist/iterator.js?");

/***/ }),

/***/ "./node_modules/lru-cache/node_modules/yallist/yallist.js":
/*!****************************************************************!*\
  !*** ./node_modules/lru-cache/node_modules/yallist/yallist.js ***!
  \****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/*! CommonJS bailout: module.exports is used directly at 2:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"./node_modules/lru-cache/node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n\n\n//# sourceURL=webpack://cic/./node_modules/lru-cache/node_modules/yallist/yallist.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 529:0-14 */
/***/ ((module) => {

"use strict";
eval("// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://cic/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "?8465":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://cic/crypto_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./dist/index.js");
/******/ })()
;